{
  "BuildInfo":{
    "Date":"Sun Apr 24 16:05:43 2022",
    "TypeWriter":{
      "Name":"TypeWriter",
      "Version":"4.0.0",
      "Licence":"MIT"
    }
  },
  "Package":{
    "Contact":{
      "Socials":[],
      "Website":"",
      "Source":"https://github.com/SinisterRectus/Discordia/blob/master/libs/utils/Emitter.lua"
    },
    "Name":"BetterEmitter",
    "ID":"BetterEmitter",
    "Entrypoints":{
      "Main":"ga.corebyte.BetterEmitter.Test"
    },
    "Description":"A better emitter",
    "Version":"1.0.0",
    "Author":{
      "Contributors":[],
      "Developers":["CoreByte","SinisterRectus"]
    },
    "InfoVersion":1,
    "Dependencies":{
      "Luvit":[],
      "Dua":[],
      "Git":[]
    }
  },
  "Code":{
    "ga.corebyte.BetterEmitter.Internal.Class":{
      "Code":"local format = string.format\r\n\r\nlocal meta = {}\r\nlocal names = {}\r\nlocal classes = {}\r\nlocal objects = setmetatable({}, {__mode = 'k'})\r\n\r\nfunction meta:__call(...)\r\n\tlocal obj = setmetatable({}, self)\r\n\tobjects[obj] = true\r\n\tobj:__init(...)\r\n\treturn obj\r\nend\r\n\r\nfunction meta:__tostring()\r\n\treturn 'class ' .. self.__name\r\nend\r\n\r\nlocal default = {}\r\n\r\nfunction default:__tostring()\r\n\treturn self.__name\r\nend\r\n\r\nfunction default:__hash()\r\n\treturn self\r\nend\r\n\r\nlocal function isClass(cls)\r\n\treturn classes[cls]\r\nend\r\n\r\nlocal function isObject(obj)\r\n\treturn objects[obj]\r\nend\r\n\r\nlocal function isSubclass(sub, cls)\r\n\tif isClass(sub) and isClass(cls) then\r\n\t\tif sub == cls then\r\n\t\t\treturn true\r\n\t\telse\r\n\t\t\tfor _, base in ipairs(sub.__bases) do\r\n\t\t\t\tif isSubclass(base, cls) then\r\n\t\t\t\t\treturn true\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\n\treturn false\r\nend\r\n\r\nlocal function isInstance(obj, cls)\r\n\treturn isObject(obj) and isSubclass(obj.__class, cls)\r\nend\r\n\r\nlocal function profile()\r\n\tlocal ret = setmetatable({}, {__index = function() return 0 end})\r\n\tfor obj in pairs(objects) do\r\n\t\tlocal name = obj.__name\r\n\t\tret[name] = ret[name] + 1\r\n\tend\r\n\treturn ret\r\nend\r\n\r\nlocal types = {['string'] = true, ['number'] = true, ['boolean'] = true}\r\n\r\nlocal function _getPrimitive(v)\r\n\treturn types[type(v)] and v or v ~= nil and tostring(v) or nil\r\nend\r\n\r\nlocal function serialize(obj)\r\n\tif isObject(obj) then\r\n\t\tlocal ret = {}\r\n\t\tfor k, v in pairs(obj.__getters) do\r\n\t\t\tret[k] = _getPrimitive(v(obj))\r\n\t\tend\r\n\t\treturn ret\r\n\telse\r\n\t\treturn _getPrimitive(obj)\r\n\tend\r\nend\r\n\r\nlocal rawtype = type\r\nlocal function type(obj)\r\n\treturn isObject(obj) and obj.__name or rawtype(obj)\r\nend\r\n\r\nreturn setmetatable({\r\n\r\n\tclasses = names,\r\n\tisClass = isClass,\r\n\tisObject = isObject,\r\n\tisSubclass = isSubclass,\r\n\tisInstance = isInstance,\r\n\ttype = type,\r\n\tprofile = profile,\r\n\tserialize = serialize,\r\n\r\n}, {__call = function(_, name, ...)\r\n\r\n\tif names[name] then return error(format('Class %q already defined', name)) end\r\n\r\n\tlocal class = setmetatable({}, meta)\r\n\tclasses[class] = true\r\n\r\n\tfor k, v in pairs(default) do\r\n\t\tclass[k] = v\r\n\tend\r\n\r\n\tlocal bases = {...}\r\n\tlocal getters = {}\r\n\tlocal setters = {}\r\n\r\n\tfor _, base in ipairs(bases) do\r\n\t\tfor k1, v1 in pairs(base) do\r\n\t\t\tclass[k1] = v1\r\n\t\t\tfor k2, v2 in pairs(base.__getters) do\r\n\t\t\t\tgetters[k2] = v2\r\n\t\t\tend\r\n\t\t\tfor k2, v2 in pairs(base.__setters) do\r\n\t\t\t\tsetters[k2] = v2\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\n\r\n\tclass.__name = name\r\n\tclass.__class = class\r\n\tclass.__bases = bases\r\n\tclass.__getters = getters\r\n\tclass.__setters = setters\r\n\r\n\tlocal pool = {}\r\n\tlocal n = #pool\r\n\r\n\tfunction class:__index(k)\r\n\t\tif getters[k] then\r\n\t\t\treturn getters[k](self)\r\n\t\telseif pool[k] then\r\n\t\t\treturn rawget(self, pool[k])\r\n\t\telse\r\n\t\t\treturn class[k]\r\n\t\tend\r\n\tend\r\n\r\n\tfunction class:__newindex(k, v)\r\n\t\tif setters[k] then\r\n\t\t\treturn setters[k](self, v)\r\n\t\telseif class[k] or getters[k] then\r\n\t\t\treturn error(format('Cannot overwrite protected property: %s.%s', name, k))\r\n\t\telseif k:find('_', 1, true) ~= 1 then\r\n\t\t\treturn error(format('Cannot write property to object without leading underscore: %s.%s', name, k))\r\n\t\telse\r\n\t\t\tif not pool[k] then\r\n\t\t\t\tn = n + 1\r\n\t\t\t\tpool[k] = n\r\n\t\t\tend\r\n\t\t\treturn rawset(self, pool[k], v)\r\n\t\tend\r\n\tend\r\n\r\n\tnames[name] = class\r\n\r\n\treturn class, getters, setters\r\n\r\nend})",
      "Type":"Code"
    },
    "ga.corebyte.BetterEmitter":{
      "Type":"Redirect",
      "RedirectTo":"ga.corebyte.BetterEmitter.Main"
    },
    "ga.corebyte.BetterEmitter.Test":{
      "Code":"local Emitter = Import(\"ga.corebyte.BetterEmitter\"):new()\r\n\r\nEmitter:on(\r\n    \"test\",\r\n    function(data)\r\n        print(\"test event fired with data: \" .. data)\r\n    end\r\n)\r\n\r\nEmitter:emit(\"test\", \"hello world\")",
      "Type":"Code"
    },
    "ga.corebyte.BetterEmitter.ProxiedClass":{
      "Code":"local Emitter = Class:extend()\r\n\r\nlocal InternalEmitter = Import(\"ga.corebyte.BetterEmitter.Internal.Emitter\")\r\n\r\nfunction Emitter:initialize()\r\n    self.InternalEmitter = InternalEmitter()\r\nend\r\n\r\n--#region Emit functions\r\nfunction Emitter:Emit(Name, ...)\r\n    return self.InternalEmitter:emit(Name, ...)\r\nend\r\n\r\nfunction Emitter:emit(Name, ...)\r\n    return self:Emit(Name, ...)\r\nend\r\n\r\nfunction Emitter:Fire(Name, ...)\r\n    return self:Emit(Name, ...)\r\nend\r\n\r\nfunction Emitter:fire(Name, ...)\r\n    return self:Emit(Name, ...)\r\nend\r\n--#endregion\r\n\r\n--#region GetListenerCount functions\r\nfunction Emitter:GetListenerCount(Name)\r\n    return self.InternalEmitter:getListenerCount(Name)\r\nend\r\n\r\nfunction Emitter:getListenerCount(Name)\r\n    return self:GetListenerCount(Name)\r\nend\r\n--#endregion\r\n\r\n--#region GetListeners functions\r\nfunction Emitter:GetListeners(Name)\r\n    return self.InternalEmitter:getListeners(Name)\r\nend\r\n\r\nfunction Emitter:getListeners(Name)\r\n    return self:GetListeners(Name)\r\nend\r\n--#endregion\r\n\r\n--#region On functions\r\nfunction Emitter:On(Name, Fn)\r\n    return self.InternalEmitter:on(Name, Fn)\r\nend\r\n\r\nfunction Emitter:on(Name, Fn)\r\n    return self:On(Name, Fn)\r\nend\r\n--#endregion\r\n\r\n--#region OnSync functions\r\nfunction Emitter:OnSync(Name, Fn)\r\n    return self.InternalEmitter:onSync(Name, Fn)\r\nend\r\n\r\nfunction Emitter:onSync(Name, Fn)\r\n    return self:OnSync(Name, Fn)\r\nend\r\n--#endregion\r\n\r\n--#region Once functions\r\nfunction Emitter:Once(Name, Fn)\r\n    return self.InternalEmitter:once(Name, Fn)\r\nend\r\n\r\nfunction Emitter:once(Name, Fn)\r\n    return self:Once(Name, Fn)\r\nend\r\n--#endregion\r\n\r\n--#region OnceSync functions\r\nfunction Emitter:OnceSync(Name, Fn)\r\n    return self.InternalEmitter:onceSync(Name, Fn)\r\nend\r\n\r\nfunction Emitter:onceSync(Name, Fn)\r\n    return self:OnceSync(Name, Fn)\r\nend\r\n--#endregion\r\n\r\n--#region RemoveAllListeners functions\r\nfunction Emitter:RemoveAllListeners(Name)\r\n    return self.InternalEmitter:removeAllListeners(Name)\r\nend\r\n\r\nfunction Emitter:removeAllListeners(Name)\r\n    return self:RemoveAllListeners(Name)\r\nend\r\n--#endregion\r\n\r\n--#region RemoveListener functions\r\nfunction Emitter:RemoveListener(Name, Fn)\r\n    return self.InternalEmitter:removeListener(Name, Fn)\r\nend\r\n\r\nfunction Emitter:removeListener(Name, Fn)\r\n    return self:RemoveListener(Name, Fn)\r\nend\r\n--#endregion\r\n\r\n--#region\r\nfunction Emitter:WaitFor(Name, Timeout, Predicate)\r\n    return self.InternalEmitter:waitFor(Name, Timeout, Predicate)\r\nend\r\n\r\nfunction Emitter:waitFor(Name, Timeout, Predicate)\r\n    return self:WaitFor(Name, Timeout, Predicate)\r\nend\r\n--#endregion\r\n\r\nreturn Emitter",
      "Type":"Code"
    },
    "ga.corebyte.BetterEmitter.Internal.Emitter":{
      "Code":"--[=[\r\n@c Emitter\r\n@t ui\r\n@mt mem\r\n@d Implements an asynchronous event emitter where callbacks can be subscribed to\r\nspecific named events. When events are emitted, the callbacks are called in the\r\norder that they were originally registered.\r\n]=]\r\n\r\nlocal timer = require('timer')\r\n\r\nlocal wrap, yield = coroutine.wrap, coroutine.yield\r\nlocal resume, running = coroutine.resume, coroutine.running\r\nlocal insert, remove = table.insert, table.remove\r\nlocal setTimeout, clearTimeout = timer.setTimeout, timer.clearTimeout\r\n\r\nlocal Emitter = Import(\"ga.corebyte.BetterEmitter.Internal.Class\")('Emitter')\r\n\r\nfunction Emitter:__init()\r\n\tself._listeners = {}\r\nend\r\n\r\nlocal function new(self, name, listener)\r\n\tlocal listeners = self._listeners[name]\r\n\tif not listeners then\r\n\t\tlisteners = {}\r\n\t\tself._listeners[name] = listeners\r\n\tend\r\n\tinsert(listeners, listener)\r\n\treturn listener.fn\r\nend\r\n\r\n--[=[\r\n@m on\r\n@p name string\r\n@p fn function\r\n@r function\r\n@d Subscribes a callback to be called every time the named event is emitted.\r\nCallbacks registered with this method will automatically be wrapped as a new\r\ncoroutine when they are called. Returns the original callback for convenience.\r\n]=]\r\nfunction Emitter:on(name, fn)\r\n\treturn new(self, name, {fn = fn})\r\nend\r\n\r\n--[=[\r\n@m once\r\n@p name string\r\n@p fn function\r\n@r function\r\n@d Subscribes a callback to be called only the first time this event is emitted.\r\nCallbacks registered with this method will automatically be wrapped as a new\r\ncoroutine when they are called. Returns the original callback for convenience.\r\n]=]\r\nfunction Emitter:once(name, fn)\r\n\treturn new(self, name, {fn = fn, once = true})\r\nend\r\n\r\n--[=[\r\n@m onSync\r\n@p name string\r\n@p fn function\r\n@r function\r\n@d Subscribes a callback to be called every time the named event is emitted.\r\nCallbacks registered with this method are not automatically wrapped as a\r\ncoroutine. Returns the original callback for convenience.\r\n]=]\r\nfunction Emitter:onSync(name, fn)\r\n\treturn new(self, name, {fn = fn, sync = true})\r\nend\r\n\r\n--[=[\r\n@m onceSync\r\n@p name string\r\n@p fn function\r\n@r function\r\n@d Subscribes a callback to be called only the first time this event is emitted.\r\nCallbacks registered with this method are not automatically wrapped as a coroutine.\r\nReturns the original callback for convenience.\r\n]=]\r\nfunction Emitter:onceSync(name, fn)\r\n\treturn new(self, name, {fn = fn, once = true, sync = true})\r\nend\r\n\r\n--[=[\r\n@m emit\r\n@p name string\r\n@op ... *\r\n@r nil\r\n@d Emits the named event and a variable number of arguments to pass to the event callbacks.\r\n]=]\r\nfunction Emitter:emit(name, ...)\r\n\tlocal listeners = self._listeners[name]\r\n\tif not listeners then return end\r\n\tfor i = 1, #listeners do\r\n\t\tlocal listener = listeners[i]\r\n\t\tif listener then\r\n\t\t\tlocal fn = listener.fn\r\n\t\t\tif listener.once then\r\n\t\t\t\tlisteners[i] = false\r\n\t\t\tend\r\n\t\t\tif listener.sync then\r\n\t\t\t\tfn(...)\r\n\t\t\telse\r\n\t\t\t\twrap(fn)(...)\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\n\tif listeners._removed then\r\n\t\tfor i = #listeners, 1, -1 do\r\n\t\t\tif not listeners[i] then\r\n\t\t\t\tremove(listeners, i)\r\n\t\t\tend\r\n\t\tend\r\n\t\tif #listeners == 0 then\r\n\t\t\tself._listeners[name] = nil\r\n\t\tend\r\n\t\tlisteners._removed = nil\r\n\tend\r\nend\r\n\r\n--[=[\r\n@m getListeners\r\n@p name string\r\n@r function\r\n@d Returns an iterator for all callbacks registered to the named event.\r\n]=]\r\nfunction Emitter:getListeners(name)\r\n\tlocal listeners = self._listeners[name]\r\n\tif not listeners then return function() end end\r\n\tlocal i = 0\r\n\treturn function()\r\n\t\twhile i < #listeners do\r\n\t\t\ti = i + 1\r\n\t\t\tif listeners[i] then\r\n\t\t\t\treturn listeners[i].fn\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\nend\r\n\r\n--[=[\r\n@m getListenerCount\r\n@p name string\r\n@r number\r\n@d Returns the number of callbacks registered to the named event.\r\n]=]\r\nfunction Emitter:getListenerCount(name)\r\n\tlocal listeners = self._listeners[name]\r\n\tif not listeners then return 0 end\r\n\tlocal n = 0\r\n\tfor _, listener in ipairs(listeners) do\r\n\t\tif listener then\r\n\t\t\tn = n + 1\r\n\t\tend\r\n\tend\r\n\treturn n\r\nend\r\n\r\n--[=[\r\n@m removeListener\r\n@p name string\r\n@p fn function\r\n@r nil\r\n@d Unregisters all instances of the callback from the named event.\r\n]=]\r\nfunction Emitter:removeListener(name, fn)\r\n\tlocal listeners = self._listeners[name]\r\n\tif not listeners then return end\r\n\tfor i, listener in ipairs(listeners) do\r\n\t\tif listener and listener.fn == fn then\r\n\t\t\tlisteners[i] = false\r\n\t\tend\r\n\tend\r\n\tlisteners._removed = true\r\nend\r\n\r\n--[=[\r\n@m removeAllListeners\r\n@p name string/nil\r\n@r nil\r\n@d Unregisters all callbacks for the emitter. If a name is passed, then only\r\ncallbacks for that specific event are unregistered.\r\n]=]\r\nfunction Emitter:removeAllListeners(name)\r\n\tif name then\r\n\t\tself._listeners[name] = nil\r\n\telse\r\n\t\tfor k in pairs(self._listeners) do\r\n\t\t\tself._listeners[k] = nil\r\n\t\tend\r\n\tend\r\nend\r\n\r\n--[=[\r\n@m waitFor\r\n@p name string\r\n@op timeout number\r\n@op predicate function\r\n@r boolean\r\n@r ...\r\n@d When called inside of a coroutine, this will yield the coroutine until the\r\nnamed event is emitted. If a timeout (in milliseconds) is provided, the function\r\nwill return after the time expires, regardless of whether the event is emitted,\r\nand `false` will be returned; otherwise, `true` is returned. If a predicate is\r\nprovided, events that do not pass the predicate will be ignored.\r\n]=]\r\nfunction Emitter:waitFor(name, timeout, predicate)\r\n\tlocal thread = running()\r\n\tlocal fn\r\n\tfn = self:onSync(name, function(...)\r\n\t\tif predicate and not predicate(...) then return end\r\n\t\tif timeout then\r\n\t\t\tclearTimeout(timeout)\r\n\t\tend\r\n\t\tself:removeListener(name, fn)\r\n\t\treturn assert(resume(thread, true, ...))\r\n\tend)\r\n\ttimeout = timeout and setTimeout(timeout, function()\r\n\t\tself:removeListener(name, fn)\r\n\t\treturn assert(resume(thread, false))\r\n\tend)\r\n\treturn yield()\r\nend\r\n\r\nreturn Emitter",
      "Type":"Code"
    },
    "ga.corebyte.BetterEmitter.Main":{
      "Code":"return Import(\"ga.corebyte.BetterEmitter.ProxiedClass\")",
      "Type":"Code"
    }
  },
  "Resources":[]
}